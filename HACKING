How to Help!
============

  Of course, like any open-source project, help is welcome.  Please,
  please, PLEASE read this file first, though:  I am a fairly nit-picky
  person, I suppose.  Most of this document is about how to prepare
  patches for being sent for inclusion into AllTray.

  First, AllTray uses the Bazaar[1] revision control system.  This means
  that you don't have to work with patches directly if you don't want
  to.  Of course, you still can---but it would be easier if you'd use
  Bazaar and create your own personal branch on Launchpad, and then just
  request that I pull from it.

 Patching AllTray
 ----------------

  To get started, you’ll need a bleeding-edge copy of the source code.
  After the 0.7.1dev release, you can pull the bleeding-edge (trunk,
  mainline, whatever you want to call it) by simply running:

   $ bzr branch lp:alltray

  Which will give you the development tree for AllTray.  (I say after
  0.7.1dev, because 0.7.1dev is essentially going to be a somewhat major
  undertaking and massive rewrite; people may or may not want to jump in
  and start working on it when it’s going to be so actively up
  in-the-air.)

  Then, it’s time to write your changes; make modifications, add files,
  delete files, whatever.  Commit as (in)frequently as you want to your
  local branch---after all, it's yours!  See below for the rules.

 Code Formatting
 ---------------

  Code formatting is pretty simple:

    * Indentations are two spaces and NEVER, EVER tabs.

    * Lines are no longer than 80 characters, unless for some reason it
      is ABSOLUTELY necessary to have a line that is longer (e.g., it
      can't be trimmed due to technical reasons).

    * Blank lines must be truly blank; they must contain only a UNIX
      newline.  No spaces or other non-printing (whitespace) characters.

    * Functions should be no longer than 25-50 lines when possible.
      There are of course going to be exceptions, but break functions
      down into small chunks whenever possible (this also tends to
      increase the utility of functions in the code base).  Essentially,
      though, a function should be less than a screen-full of lines at a
      reasonable point size in an editor such as GNU Emacs or any
      terminal-based editor.

      In the event that functions *do* run long, keeping the lines under
      80 characters is even more important---80 character lines are the
      largest that many printers will actually print by default.  Also,
      terminals default to being 80 characters wide, as does the GNU
      Emacs text editor.  ;-)

    * Global prototypes go in <alltray.h>.

    * Global functions must be prefixed with alltray_$MODULENAME_.  For
      example, all global functions in the x11.c module begin with
      alltray_x11_ (e.g., alltray_x11_init()).

    * Static (local) functions MUST NOT use a prefix unless there is a
      clash with something else.  In the event of a clash, ALL static
      functions in a module (for consistency) acquire a $MODULENAME_
      prefix.  However, do not use alltray_$MODULENAME_ for a prefix,
      since that is a visual cue that the function is a global function
      and can be called from elsewhere.

    * Global data MUST be located in global.c, and referenced from
      <alltray.h>.  Adding any global data is strongly, strongly
      discouraged unless it is absolutely the only way to do something.

    * All includes are centrally included in <alltray.h>.

    * All structures must be typedef’d to an appropriate name.

    * New structures must be located in a module file unless there is a
      requirement for their use throughout the entire program.  It is
      easier to promote from local to global, than to demote from
      global to local.

    * New functions are REQUIRED to have docstrings which can be parsed
      by Doxygen.  These start with /** and end with */; see any source
      file for an example of them.  It would be nice if new data had
      them, too.

    * Readability is paramount, but please try to keep unnecessary
      whitespace to a minimum.  I *hate* things like:

        function_call ( param, ( x + y ) );

      And I think it is absolutely, positively HORRIBLE.  This is
      better:

        function_call(param, (x + y));

      Use an editor that highlights the matching brace so you do not
      have to brace-count, too.

 DOs and DON’Ts
 --------------

 I am a bit picky, perhaps even O-C about the code.  That's more than I
 can say about my meatspace desk, but still...

  * DO use bzr for development, so that you can continually rebase your
    changes against the trunk if they take more than a very small amount
    of time to work with (or at least so that you can easily rebase them
    at the end of your work).  You can do this with straight patches,
    but it is much harder.  I won't fold anything in that doesn't
    cleanly merge against the trunk!  Note that this also means that if
    you ask to merge and someone else does, and the merges somehow
    conflict with each other, I will ask somebody to rebase and fix
    unless it's trivial.

  * DO use UTF-8 in code and documentation.  We no longer live in an
    ASCII world.  ASCII is fine, too, but you are not compelled to use
    it.

  * DO use ISO C99 with GNU extensions.  The GNU compiler is available
    damn near everywhere, and it (the compiler) is the de facto
    standard.  We require C99 and GNU extensions for the most part,
    anyway.

  * DO write portable (to other operating systems) code when at all
    possible, and if you read code that you know to be non-portable,
    modify it with portable code (and test your changes).

  * DO use the debugging macros when writing code.  If you need a new
    category of debugging messages, DO create it---it isn’t that hard,
    see debug.c and alltray.h.

  * DO (_always_) build your code with “-Wall -Werror” enabled before
    asking for it to be merged into the mainline.  If it doesn’t build
    with “-Wall -Werror”, I won’t even think about it.  Quality is
    important.  If you really want to make sure the code is good, use
    “-Wall -Wextra -Werror”, which will tell you about other things that
    can be fixed.  Personally, my goal is to compile quietly using the
    latter option, simply because we can.  It is, of course, quite
    alright to have your interim commits not be clean, as long as the
    final result of the work is when merging is requested.

  * DO reasonably test changes.  Obviously, they do not have to be 100%
    bug-free, since you’re working on the development tree, it is
    probably not bug-free anyway.  But make it as good as you can
    without paralyzing yourself.

  * DO ask for help if you need it.

  * DO fix-as-you-go.  Think of the program as the pile of dishes in the
    kitchen---leave it better than you found it if at all possible.

  * DO write flexible code.  If you need to initialize 20 things, try to
    loop over them to get to it, instead of hard-coding every one in a
    function.  (Good example: see x11.c, static gchar *atoms[] and
    static void local_atoms_init().)  This makes things more
    maintainable.

  * DO write code to be read by humans; use extra whitespace, explain
    magic numbers or NULL values with a quick comment, and generally
    format code like it already is.  Prefer declaring short-lived
    temporary variables to function call chaining or direct function
    calls in if statements, unless the function call in the if statement
    reads well.  For example, the following is not terribly fun to read
    (g_spawn_async() takes 8 parameters and makes this look horrible):

       if(g_spawn_async(...))

    Instead, use:

       gboolean status = g_spawn_async(...);
       if(status == FALSE) { ... }

    This also means that when testing things, make the tests readable.
    For example, the following I think is ugly:

       if(isatty(fileno(stdout))) { ... }

    I think that this is much better:

       gboolean
       output_is_terminal() {
         return(isatty(fileno(stdout)));
       }

       [...]

       if(output_is_terminal()) { ... }

    In short, readability is more important than simply being
    technically correct code.  Besides, the compiler will optimize a
    great deal of the code away in its various stages of the
    optimization process.

  * DO realize that I am *far* from perfect, and if you an expert in C
    programming (or portable UNIX programming), and you think I am doing
    something wrong, I probably am.  Please fix anything you find that I
    have done wrong.

  * DO understand the following statement: “We should forget about small
    efficiencies, say about 97% of the time: premature optimization is
    the root of all evil.”

    If you don’t understand it, read /Structured Programming with go to
    Statements/, the paper by Donald Knuth.[2]  Write efficiently,
    favoring the human eye slightly more than the computer’s brain.
    This is not a license to write horrible code in itself or suffer its
    existence, or a license to not think about the impact of the code
    when designing it!

  * DO use well-tested code as opposed to reinventing the wheel, unless
    it is somehow necessary.  Using a GList is much better than
    reinventing the wheel and implementing doubly-linked lists yet
    again.  GList is general and easy to use, and likely more optimized
    due to its existence and wide-spread use than what would be written
    as part of an application.

    If a library needs to have an improvement made to it, check it out,
    prepare a patch, and submit that fix to the maintainer(s).  It's
    likely to wind up taking less time than writing the functionality
    from scratch, and more people then benefit.  Of course, follow their
    style guidelines when working on their code, even if it hurts.  ;)

  * DON'T mix bulk formatting changes and code changes in a single
    commit; if patching and not committing to a bzr repository (why?!)
    then prepare two patches, one that has the bulk formatting changes,
    and one that has the subsequent code changes.  Clearly mark
    formatting-change-only commits in the log message as such.  If you
    need to make formatting changes and code changes sequentially, try
    to commit the formatting changes first in their own commit, and then
    commit the code changes.

  * DON’T write new code and have no debugging statements for it.  We
    have -D/--debug and ALLTRAY_DEBUG for a reason!

  * DON’T have debugging code which creates side effects---distributors
    ARE ALLOWED to compile the code with -DALLTRAY_NO_DEBUG to turn off
    debugging entirely if necessary!

  * DON’T be afraid to have a lot of DEBUG macro calls, there really
    cannot be too many of them.

  * DON’T directly test for debug flags; DO always use the macro calls,
    which provide output in a consistent format.

  * DON'T hard-code values into the code.  Things like the program name
    and version number are defined as macros that evaluate to strings;
    if you have magic numbers or certain types of embedded strings, do
    this for them, as well.  The only exception to this is atom and
    property names for the X Window System, because the strings are
    actually the keys for numbers that the X Window System stores
    internally to the server.

Links
-----

  [1] http://bazaar-vcs.org/
  [2] http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf
